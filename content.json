{"pages":[{"title":"","text":"Code style linter for Crystal (a single-celled animal that catches food and moves about by extending fingerlike projections of protoplasm) Fast Written in Crystal. Utilizes AST parser and lexer. Takes milliseconds to process sources. Modular Ships rules, categories and reporters. Third party modules are supported. Configurable Fully customizable via command line or a configuration file. Use what you need. Recessed Rich editor support and available through third party code quality services.","link":"/index.html"}],"posts":[{"title":"Writing an extension for Ameba linter","text":"It was announced recently that Ameba is going to be extendable. That means any developer can create his own extension and use together with Ameba’s engine. Here we will be following through the steps on how to create such an extension and use it. It is going to be crystal-docs extension, where a new rule will be implemented which will enforce classes to have documentation. 1. New extension skeletonCreating a new Ameba extension is as simple as creating a new Crystal library: 1$ crystal init lib crystal-docs &amp;&amp; cd crystal-docs and adding Ameba as a dependency to shard.yml: shard.yml1234567891011121314name: ameba-docsversion: 0.1.0authors: - Vitalii Elenhaupt &lt;velenhaupt@gmail.com&gt;crystal: 0.29.0license: MITdevelopment_dependencies: ameba: github: crystal-ameba/ameba version: ~&gt; 0.10.0 It needs to be a development dependency because we don’t want to force the end application to be dependent on a specific version of Ameba. 2. Creating a ruleAmeba enforces rules to be extended from Rule::Base entity and to be a class. Let’s create one: src/ameba-docs.cr12345678910111213141516171819202122module Ameba::Rule VERSION = \"0.1.0\" class Docs ‹ Base properties do description \"Enforces public classes to be documented\" end MSG = \"Class must be documented\" def test(source) AST::NodeVisitor.new self, source end def test(source, node : Crystal::ClassDef) return unless node.visibility.public? doc = node.doc issue_for(node, MSG) if doc.nil? || doc.empty? end endend A couple of things are defined here: properties defines a dsl for configurable rule properties. We only have a rule description. MSG defines a constant for the error message to be reported. def test(source) is an entry point of the rule. Here the method accepts a source file and passes it to the node visitor, which allows us filter the ClassDef nodes in the method below. def test(source, node : Crystal::ClassDef) is a method which does an actual job. The implementation is pretty self explained: it filters out node, which have public visibility and do not have (or have empty) docs. The extension is pretty much done. Let’s try to use it. 3. Plug-in the extensionSomewhere in a separate project we want to plug-in the ameba engine and the extension we made. To do that, we need to add a development dependencies for both of this projects: shard.yml12345development_dependencies: ameba: github: crystal-ameba/ameba ameba-docs: github: crystal-ameba/ameba-docs-rule-example Then we install those deps: 123456$ shards installFetching https://github.com/veelenga/ameba.gitFetching https://github.com/crystal-ameba/ameba-docs-rule-example.gitInstalling ameba (0.10.0 at master)Installing ameba-docs (0.1.0 at master) It will create bin/ameba.cr file which is needed to built the ameba together with modules. First, we need to enable the module: bin/ameba.cr12require \"ameba/cli\" # requires Ameba's clirequire \"ameba-docs\" # requires ameba docs extension And now we are ready to build and run it: 12$ crystal build bin/ameba.cr -o bin/ameba$ bin/ameba The results are displayed below. crystal-docs extension in action: Wrap upWe made a small Ameba extension and used that in a third-party project. Of course, this was just an example of the rule and not a production ready solution. However, it is a perfect example of the power of Ameba’s modules. The sources are availabe on Github.","link":"/2019/07/22/how-to-write-extension/"},{"title":"Ameba v0.11.0 - New rules, lint in parallel, GitHub action and more.","text":"Ameba v0.11.0 has been released. Here we will go through the main features and improvements which are included to this release. Also, will do benchmarking comparing parallel linting using Crystal’s experimental parallelism and will explain how to use Ameba together with GitHub actions. New RulesCrystal has several handy methods to iterate over collection together with index/object: Enumerable#each_with_index Enumerable#each_with_object Iterable#each_with_index Iterable#each_with_object They are usually used in places where an extra block argument (index or object) is needed: 123collection.each.with_index do |e, index| puts e, indexend However, sometimes after a couple of refactoring rounds, people realize they don’t need that additional argument anymore and forget to remove that extra call to with_index (or with_object). Examples: 1234567891011collection.each.with_index do |e| puts eendcollection.each_with_index do |e, _| puts eendcollection.each_with_object(0) do |e| puts eend Now, all cases above are reported by Ameba. The suggested way to change it will be the following: 123collection.each do |e| puts eend If your source code is not ready for these enforcements, they can be disabled in .ameba.yml via: 12345Lint/RedundantWithIndex: Enabled: false Lint/RedundantWithObject: Enabled: false Parallel lintingCrystal started to support parallism as an experimental feature starting from 0.31.0. The main intention here is speed, which is achieved by doing several things in parallel. Ameba is a small set of rules and enforcements and in most cases, it takes a couple of seconds to lint an average shard. However, we still find it useful to parallize the linting, especially on a large amount of sources. We found that the easiest way to run linting in parallel is to spawn each source into it’s own channel. And since issues are added to the sources, we don’t have to care about thread safely, because a full set of rules will be running sequentially on each source in it’s own thread. So the only thing which is needed is to wait the hole inspection on all sources at the end and gather results. At a high level, it looks similar to this: 1234567891011channels = sources.map { Channel(Nil).new }sources.each_with_index do |source, idx| channel = channels[idx] spawn do inspect(source) # run full set of rules channel.send(nil) endendchannels.each { |c| c.receive } In reality, it is a bit more complex and it was simplified just to explain the concept. Let’s do some benchmarking now. At first, we need to build Ameba using the preview_mt flag and install it manually: 12$ crystal build src/cli.cr -Dpreview_mt -o bin/ameba$ sudo make install And then we can try running it on Crystal repo (1449 files for the moment) using different amount of crystal workers: 1234$ time CRYSTAL_WORKERS=1 ameba --silent # 27.78s user 0.34s system 99% cpu 28.116 total$ time CRYSTAL_WORKERS=2 ameba --silent # 29.54s user 0.22s system 147% cpu 20.184 total$ time CRYSTAL_WORKERS=4 ameba --silent # 30.90s user 0.28s system 226% cpu 13.742 total$ time CRYSTAL_WORKERS=8 ameba --silent # 44.67s user 0.44s system 413% cpu 10.900 total If you look at the total part, you will find that the max time is 28.116 seconds and the min one is 10.900 seconds. So we were able to run it almost 3 times faster on 8 workers. However, the results are not linear to the amount of workers. And that is expected, because our sources (or more accurate, lines of code) are not divided evenly and some workers have to inspect bigger sources and other workers will have to wait until they finish. Of course, someone can say that we can pre-calculate the LoCs and divide the work more evenly. And it would be true. But that would complicate our implementation a lot. So here we decided to make it as simple as possible and keep the room opened for the future improvements. At the end, we must say that this feature is fully functional and reliable on Ameba’s side. It was well tested using different formatters, so the end user is free to try it to inspect his crystal code in parallel. We are looking for the best results, keep us posted! GitHub ActionAmeba GitHub action has been released and the first version has been published to the GitHub marketplace. The easiest way to use it is to follow installation intructions: 123456# Copy and paste the following snippet into your .yml file.- name: Crystal Ameba Linter uses: crystal-ameba/github-action@v0.1.1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} And here is an example of the workflow with Ameba and Crystal specs: 12345678910111213141516171819202122232425# Create .github/workflows/crystal.yml in your repositoryname: Crystal CIon: [push]jobs: build: runs-on: ubuntu-latest container: image: crystallang/crystal steps: - uses: actions/checkout@v1 - name: Crystal Ameba Linter id: crystal-ameba uses: crystal-ameba/github-action@v0.1.1 env: GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} - name: Install dependencies run: shards install - name: Run tests run: crystal spec Once this is added to GitHub action workflow, Ameba will start reporting annotations in pull requests: Keep in mind, that is very first release for this GitHub action and it misses a couple of required configuration options. However, it still uses .ameba.yml config in the repository root and properly configures rules before running the inspection. Hope you would enjoy it! MoreThis release also includes a couple of bug fixes and small improvements. Checkout the release notes for more details.","link":"/2019/11/28/release-v0.11.0/"},{"title":"Ameba's internals","text":"In this article you will find a high level overview of the Ameba’s modules, which will help to understand how it works internally. We will cover everything needed starting from source code loading and finishing by showing results of static analysis. Ameba and similar command-line applications for static analysis are required to be highly configurable. The end-user, usually, is able to change the configuration, disable or enable that or another checker/rule. Also, he is capable to change the format of the output results. Most of the static analysis tools allow inline disabling and much more… As you can see, there are a lot of different requirements for such kind of tools and the appropriate design is a key for a good tool architecture and convenient usage. Let’s take a look at the high-level picture of Ameba’s module architecture. Source LoadingOf course, the first step of static code analysis is a loading of that source code. It does not matter whether it is a file, a steam or just a regular string, Ameba is capable to read that and create a new Source abstraction. Such internal representation of source code is very convenient to operate on it. For example, it is possible to attach an Issue to this source. Source also can be created programatically: 12345678910111213require \"ameba\"source = Ameba::Source.new %( class Ameba::Internals getter info : Info def explain puts info end end), \"source.cr\"source.issues # =&gt; [] AST ParsingUnprocessed source code is a very difficult format for static analysis. Fortunately, Crystal language can do a lot of different ways of source code pre-processing, including AST parsing. List of AST nodes is a quite convenient representation of a source code to decompose. It is widely used by Ameba internally to do a static analysis. As you might have noticed, a Source responds to #ast method, which returns a list of AST nodes for that source: 123456789source.ast # =&gt; # class Ameba::Internals # getter(info : Info) # def explain # puts(info) # end # endsource.ast.class # =&gt; Crystal::ClassDef In this example, ast method returns an instance of Crystal::ClassDef because the top level node in the source code is a class, which is parsed by Crystal’s AST parser as ClassDef. Next, nodes are iterated by rules. RulesRule is a basic abstraction that iterates over that or other representation of source code and report issues if such are detected. All rules inherit from Rule::Base. Most rules visit AST nodes. There is a couple of different visitors which pass needed nodes to the handler. Let’s say there is a rule that disallows calling puts in a code. A simple version of it could look like this: 12345678910111213module Ameba::Rule # A rule that disallows calls to `puts` method. class NoPuts ‹ Base def test(source) AST::NodeVisitor.new self, source end def test(source, node : Crystal::Call) return unless node.name == \"puts\" source.add_issue(self, node, \"puts method is called\") end endend There are two different test method. The first one, which accepts a source is a main entry point to the rule. It returns the AST::NodeVisitor which will visit AST nodes and pass only needed ones to the second test method (handler). In a handler we just explore the node properties and add issues to the source code if the node matches the expectations. So, in such a way a Source is passed to all the rules and can hold some issues on it: 1234567891011121314151617rule = Ameba::Rule::NoPuts.newrule.catch(source)source.issues # =&gt; # [ # Ameba::Issue( # @rule=Ameba::Rule::Lint::NoPuts( # @enabled=true, # @severity=Warning, # @excluded=nil # ), # @message=\"puts method is called\", # @location=..., # @end_location=..., # @status=nil # ) # ] Now the source holds an issue. It’s a time to report it. Format resultsFormatters are used to format the output reported by Ameba. For example, ExplainFormatter is designed to show the detailed explanation of the issue in the source at a specific location. Another one is JSONFormatter which formats to JSON. Let’s give it a try: 1234formatter = Ameba::Formatter::JSONFormatter.new(STDOUT)formatter.started([source])formatter.source_finished(source)formatter.finished([source]) Formatters are designed to update its states using hooks, like started - a hook to be called when inspection is started source_finished - inspection of a single source is finished finished - inspection is finished If we compile the source code above and run it, we will see: 12345678910111213141516171819202122232425262728293031{ \"metadata\": { \"ameba_version\": \"0.10.0\", \"crystal_version\": \"0.30.0\" }, \"sources\": [ { \"issues\": [ { \"end_location\": { \"column\": 15, \"line\": 6 }, \"location\": { \"column\": 7, \"line\": 6 }, \"message\": \"puts method is called\", \"rule_name\": \"NoPuts\", \"severity\": \"Convention\" } ], \"path\": \"source.cr\" } ], \"summary\": { \"issues_count\": 1, \"target_sources_count\": 1 }} Congratulations, we successfully analyzed our source code and reported an issue. Wrap-upIn this tutorial we went through the steps to programatically load source code, parse it into AST nodes, create a custom rule, create an issue and show results. It covers the full loop, which Ameba does while doing static analysis. So it can help to understand how it works internally. The code used above is available as a gist. Hope you find it useful. Cheers!","link":"/2019/09/03/internals/"},{"title":"Ameba v0.13.0 has been released","text":"A very small release that supports Crystal 0.35.0 and eliminates the deprecation messages which are related to yaml serialization. Checkout the release notes to see a full scope of changes. Move to YAML::SerializableEach rule in Ameba can be serialized to YAML and deserialized back to the Crystal struct. This is needed in order to give users an ability to configure the Ameba binary using the configuration file .ameba.yml. And in order to deserialize, Ameba used YAML.mapping macro. And starting from Crystal 0.35.0 this macro is deprecated since there is a better alternative which is the YAML::Serializable module. Starting from this release, Ameba uses YAML::Serializable. The older version of Ameba still works with Crystal 0.35.0 however, users might see the deprecation warning while compiling the binary. New RulesLint/BadDirectiveThis is a new rule that reports the incorrect comment directive for Ameba. For example, the user can mistakenly add a directive to disable a rule that even doesn’t exist: 1234# ameba:disable BadRuleNamedef foo :barend Now, such a comment directive above will be propertly reported. Style/IsANilCrystal has two ways for checking the nil equality: .is_a?(Nil) and .nil?. Since the second is much more consice and doing basically the same, now Ameba disallows calls to .is_a?(Nil) in favor of .nil?. This is considered bad: 1var.is_a? Nil And needs to be written as: 1var.nil? SupportA new Patreon page has been created recently to support Ameba. If you enjoy the project please consider becoming a patreon which will give more attention to the project from the development perspective and make it better.","link":"/2020/06/22/release-v0.13.0/"},{"title":"Ameba v0.12.0 has been released","text":"Checkout the release notes to see a full scope of changes. Here we will go through the most important changes. Globs and Excluded configuration optionsAmeba now allows to globally configure the list of sources to run the inspection on. There are two new sections which can be added to .ameba.yml: 123456Globs: - **/*.cr - !lib Excluded: - src/compiler Globs is used to define paths to include to the inspection. Defaults to %w(**/*.cr !lib) Excluded is used to exclude from the list defined by Globs Crystal 0.34 compatibilityCrystal 0.34 is not yet released, but thanks to @bcardiff Ameba is now ready to the upcoming release and is still compatible to the current Crystal version 0.33. New RulesStyle/RedundantNextCrystal has next keyword which can be used to go to the next iteration in a loop. However, it can also be used to exit from a block, for example: 1234(1..3).each do |e| break if e.even? puts eend # =&gt; 1, 3 And in some places next can be overused, especially when it combines in the last expression in the block. For example: 12345678910block do |v| case v when .nil? next \"nil\" when .blank? next \"blank\" else next \"empty\" endend In all three places above the next keyword is redundant and is reported by the new rule. Lint/SharedVarInFiberTo achieve concurrency and parallelism Crystal uses Fibers and Channels. There is a tricky behavior which happens when a shared variable is used across multiple fibers and is mutated during iterations. For example: 123456789n = 0channel = Channel(Int32).newwhile n ‹ 3 n = n + 1 spawn { channel.send n }end3.times { puts channel.receive } You might expect the code above to print 1 2 3, however it prints 3 3 3. The problem is there is a shared variable n and when channel.receive is executed its value is 3. To solve it, the code above can be written to the following: 1234567891011n = 0channel = Channel(Int32).newwhile n ‹ 3 n = n + 1+ m = n- spawn do { channel.send n }+ spawn do { channel.send m }end3.times { puts channel.receive } So instead of using a shared variable n which is declared at the top and mutated in a while loop, we reassign the value to variable m and use it in our spawn. As the result, the code above prints the expected 1 2 3. The new rule properly reports the issue on the first sample and passes on the second one. There are also other technics to solve the problem above which are officially documented. Lint/EmptyLoopAfter some round of refactoring it can happen that the loop body becomes empty but for whatever reason such an empty loop is forgotten to be removed. A new rule is able to detect a few situations: 1234567891011while true # empty bodyenduntil false # empty bodyendloop do # empty blockend And these samples are valid and not reported: 12345678a = 1while a ‹ 10 a += 1enduntil socket_opened?; endloop { run } Lint/RedundantStringCoercionThis is typical situation when a value is being converted to string using Object.to_s method in the interpolation. 1\"Hello, #{name.to_s}\" Since each value enclosed by { ... } ends up invoking Object.to_s explicit calls are redundant and are now reported by Ameba. The code above is forced to be changed to 1\"Hello, #{name}\" SupportA new Patreon page has been created recently to support Ameba. If you enjoy the project please consider becoming a patreon which will give more attention to the project from the development perspective and make it better.","link":"/2020/03/27/release-v0.12.0/"},{"title":"Ameba v1.0.0 has been released","text":"This release includes a long-waiting autocorrection feature, new rules and several improvements. Checkout the release notes to see a full scope of changes. Crystal compatibilityThis release introduces Crystal 1.4 compatibility and breaks compatibility of previous Crystal versions. Use the latest Ameba bugfix release 0.14.4 if you need a compatibility of Crystal 1.3.x or below. AutocorrectionThanks to community, there is a huge step forward implementing autocorrection for Ameba. The feature was originally developed in #248 and afterwards improved in a several cycles. Now if Ameba reports an issue which can be corrected, it adds a [Correctable] notice: 123456$ ameba --only Style/RedundantBegin src/file_utils.crsrc/file_utils.cr:428:5 [Correctable][C] Style/RedundantBegin: Redundant `begin` block detected&gt; begin ^---^ meaning, if you append a new --fix command-line flag to the command it will automatically correct the issue adding another notice [Corrected]: 123456ameba --only Style/RedundantBegin src/file_utils.cr --fixsrc/file_utils.cr:428:5 [Corrected][C] Style/RedundantBegin: Redundant `begin` block detected&gt; begin ^---^ using a git diff we can quickly check that Ameba removed a reported redundant begin block and used the exception handler as part of a method: 123456789101112131415diff --git a/src/file_utils.cr b/src/file_utils.crindex e82e3c1e1..d416ed05b 100644--- a/src/file_utils.cr+++ b/src/file_utils.cr@@ -425,10 +425,8 @@ module FileUtils # FileUtils.rm_rf(\"non_existent_file\") # ``` def rm_rf(path : Path | String) : Nil- begin- rm_r(path)- rescue File::Error- end+ rm_r(path)+ rescue File::Error end Note: not all rules support autocorrection yet, but if you see a [Correctable] flag on a reported issue, do not hesitate to autocorrect it in order to save some time during refactoring. New rulesLint/AmbiguousAssignmentA tiny rule that checks for mistyped shorthand assignments. Bad 123x =- yx =+ yx =! y Good 123x -= y # or x = -yx += y # or x = +yx != y # or x = !y Lint/DebugCallsA rule that disallows calls to debug-related methods. This is because we don’t want debug calls accidentally being committed into our codebase. 123a = 2pp! a # error: Possibly forgotten debug-related `pp!` call detecteda = a + 1 Checkout the API doc to see a full list of supported debug-related calls. Style/GuardClauseA rule that enforces a guard clause instead of wrapping the code inside a conditional expression. Bad 12345def test if something work endend Good 12345def test return unless something workend New spec matchersAmeba has a high code coverage which was obviously achieved by a big amount of tests. However, most of the rule specs were too imperative and it led to code duplication and some readability issues. In this release were introduced a new spec matchers for rule tests. This new declarative approach allows to easily track all the reported issues in specs. 12345678910111213141516171819it \"reports multiple shared variables in spawn\" do expect_issue subject, %( foo, bar, baz = 0, 0, 0 while foo &lt; 10 baz += 1 spawn do puts foo # ^^^ error: Shared variable `foo` is used in fiber puts foo + bar + baz # ^^^ error: Shared variable `foo` is used in fiber # ^^^ error: Shared variable `baz` is used in fiber end foo += 1 end )end Some explanation: ^^^ - tracks location of the reported node error - severity of the issue Shared variable 'foo' is used in fiber - the reported error message These new matchers are used internally and of course can be used by Ameba extensions. Checkout the doc for more details.","link":"/2021/10/04/release-v1.0.0/"},{"title":"Ameba v0.14.0 has been released","text":"Checkout the release notes to see a full scope of changes. Here we will go through the most important changes. New Lint RulesLint/DuplicatedRequireDuplicated requires in the source file do not have too much effect on the running program, however it creates a mess. This rule reports such cases. 123require \"./thing\"require \"./stuff\"require \"./thing\" # duplicated require Lint/SpecFocusIn specs focus: true is mainly used to focus on a spec item locally during development. However, if such change is committed, it silently runs only focused spec on all other enviroments, which is undesired. This rule reports if specs are focused. For example, this is considered invalid: 123it \"works\", focus: true do # ...end New Performance RulesPerformance/AnyInsteadOfEmptyUsing Enumerable#any? instead of Enumerable#empty? might lead to an unexpected results (like [nil, false].any? # =&gt; false). In some cases it also might be less efficient, since it iterates until the block will return a truthy value, instead of just checking if there’s at least one value present. Now this is considered bad: 1[1, 2, 3].any? and it should be written as this: 1![1, 2, 3].empty? Performance/ChainedCallWithNoBangThis rule is used to identify usage of chained calls not utilizing the bang method variants. This is a nice way to find all the places to reduce unnecessary collection allocations. For example, this is considered inefficient: 12345names = %w[Alice Bob]chars = names .flat_map(&amp;.chars) .uniq .sort And can be written as this: 12345names = %w[Alice Bob]chars = names .flat_map(&amp;.chars) .uniq! .sort! There is a configuration property that allows to add/remove the method call names to take into account during the check: 1234567Performance/ChainedCallWithNoBang: CallNames: - uniq - sort - sort_by - shuffle - reverse Performance/CompactAfterMapThis rule is used to identify usage of compact calls that follow map. Such cases can be improved using compact_map. For example, this is considered inefficient: 1%w[Alice Bob].map(&amp;.match(/^A./)).compact And can be written as this: 1%w[Alice Bob].compact_map(&amp;.match(/^A./)) Performance/FlattenAfterMapThere is a close counterpart of a previous example: flatten after map and flat_map. So there is another rule to which is used to identify this usecase. For example, this is considered inefficient: 1%w[Alice Bob].map(&amp;.chars).flatten And can be written as this: 1%w[Alice Bob].flat_map(&amp;.chars) Performance/MapInsteadOfBlockAnother performance rule which is used to identify usage of join/sum/product calls that follow map. For example, this is considered inefficient: 12(1..3).map(&amp;.to_s).join('.')(1..3).map(&amp;.*(2)).sum And can be written as this: 12(1..3).join('.', &amp;.to_s)(1..3).sum(&amp;.*(2)) New Style RulesStyle/IsAFilterThis rule is used to identify usage of is_a?/nil? calls within filters. It helps to avoid the boilerplate in filters and improve the readability. For example, this is considered invalid: 1matches.any?(&amp;.is_a?(Regex::MatchData)) And it should be written as this: 1matches.any?(Regex::MatchData) And of course there is a configuration property that allow to change the list of filter name to inspect: 12345678Style/IsAFilter: FilterNames: - select - reject - any? - all? - none? - one? Style/VerboseBlockAs you might know some blocks in Crystal can have a shorter and much nicer form. This rule is used to identify usage of single expression blocks with argument as a receiver, that can be collapsed into such a short form. For example, this is considered invalid: 1(1..3).any? { |i| i.odd? } And it should be written as this: 1(1..3).any?(&amp;.odd?) There is a bag of configuration properties, which are not yet documented, but you can give it a shot: 12345678Style/VerboseBlock: ExcludeMultipleLineBlocks: true ExcludeCallsWithBlocks: false ExcludePrefixOperators: true ExcludeOperators: false ExcludeSetters: false MaxLineLength: ~ MaxLength: 50 # use ~ to disable","link":"/2021/02/12/release-v0.14.0/"}],"tags":[{"name":"extension","slug":"extension","link":"/tags/extension/"},{"name":"releases","slug":"releases","link":"/tags/releases/"},{"name":"parser","slug":"parser","link":"/tags/parser/"},{"name":"rule","slug":"rule","link":"/tags/rule/"},{"name":"formatter","slug":"formatter","link":"/tags/formatter/"},{"name":"modules","slug":"modules","link":"/tags/modules/"}],"categories":[{"name":"Tutorial","slug":"Tutorial","link":"/categories/Tutorial/"},{"name":"Release announcement","slug":"Release-announcement","link":"/categories/Release-announcement/"}]}